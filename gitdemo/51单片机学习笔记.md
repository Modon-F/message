# S52的CPU

### 程序计数器PC

1. cpu读取指令

2. pc作为所取指令的地址,程序存储器按此地址输出指令字节

3. pc+1

# S52的各个引脚以及功能

## P0:

51系列单片机的P0、P1、P2、P3口各有其特点和用途，其中P0口与其他口的主要区别总结如下：

1. **P0口特性**：
   - P0口是8位双向口线，既可以作为输入也可以作为输出。
   - 当作为输出口使用时，P0口是**漏极开路**输出（Open Drain），这意味着在输出高电平时需要外接上拉电阻才能输出高电平。
   - P0口具有**复用功能**，在访问外部存储器（如RAM、ROM、EPROM等）时，它可以作为低8位地址总线和8位数据总线使用。在这种情况下，P0口的状态会根据读写操作自动切换。
   - P0口没有内部上拉电阻，所以在用作输出时必须外接上拉电阻来保证逻辑电平的正确输出。

2. **P1、P2、P3口特性**：
   - P1口也是8位双向I/O口，但它是标准的推挽输出结构，也就是说，在输出高电平和低电平时不需要外接上拉电阻，可以直接驱动负载。
   - P2口在访问外部存储器时提供高8位地址，但它也具备通用I/O功能，且内部带有上拉电阻。
   - P3口不仅具有通用I/O功能，而且它的每一位还兼

# AT89S52单片机的存储器结构

哈佛结构:程序存储器和数据存储器分开,并且有各自的访问指令

## 四类存储空间:

### 程序存储器空间

片内4kb,可外扩至64kb

### 数据存储器空间

片内256B,当片内不够时,可在片外扩展至64KB

### 特殊功能寄存器SFR(Special Function Register)

### 位地址空间

# 寄存器

| 寄存器名称         | 功能简述                                  | 是否可位寻址                 |
| ------------------ | ----------------------------------------- | ---------------------------- |
| **PSW**            | 程序状态字寄存器                          | 是                           |
| AC                 | 累加器溢出标志                            | 是                           |
| CY                 | 进位标志                                  | 是                           |
| F0                 | 用户可定义标志位                          | 是                           |
| RS1, RS0           | 工作寄存器组选择位                        | 是                           |
| OV                 | 溢出标志                                  | 是                           |
| P                  | 奇偶校验标志                              | 是                           |
| DPL, DPH           | 数据指针低/高位                           | 否                           |
| **SP**             | 堆栈指针寄存器                            | 否                           |
| **B**              | B寄存器                                   | 否                           |
| **DPTR**           | 数据指针寄存器（DPL与DPH组合）            | 否                           |
| **PC**             | 程序计数器                                | 否（内部使用，不可直接访问） |
| **ACC**            | 累加器                                    | 否（内部使用，不可直接访问） |
| **PSW**            | 程序状态字寄存器                          | 是                           |
| **IE**             | 中断使能寄存器                            | 是                           |
| EX0, ET0           | 外部中断0、定时器0中断使能位              | 是                           |
| EX1, ET1           | 外部中断1、定时器1中断使能位              | 是                           |
| ES                 | 串口中断使能位                            | 是                           |
| EA                 | 总中断使能位                              | 是                           |
| **IP**             | 中断优先级寄存器                          | 是                           |
| PX0, PT0           | 外部中断0、定时器0优先级设置位            | 是                           |
| PX1, PT1           | 外部中断1、定时器1优先级设置位            | 是                           |
| PS                 | 串口中断优先级设置位                      | 是                           |
| **TCON**           | 定时器/计数器控制寄存器                   | 是                           |
| TF0, TR0           | 定时器0溢出标志、运行控制位               | 是                           |
| TF1, TR1           | 定时器1溢出标志、运行控制位               | 是                           |
| IE0, IT0           | 外部中断0触发方式、边沿触发控制位         | 是                           |
| IE1, IT1           | 外部中断1触发方式、边沿触发控制位         | 是                           |
| **TMOD**           | 定时器/计数器工作模式寄存器               | 是                           |
| GATE, C/T, M1, M0  | 定时器门控、计数/定时选择、工作模式选择位 | 是                           |
| **TH0, TL0**       | 定时器0高/低位计数寄存器                  | 否                           |
| **TH1, TL1**       | 定时器1高/低位计数寄存器                  | 否                           |
| **SCON**           | 串行口控制寄存器                          | 是                           |
| SM0, SM1           | 串行口工作模式选择位                      | 是                           |
| SM2                | 多机通信控制位                            | 是                           |
| REN                | 接收使能位                                | 是                           |
| TB8, RB8           | 发送/接收数据的第9位                      | 是                           |
| TI, RI             | 发送/接收中断标志位                       | 是                           |
| **P0, P1, P2, P3** | 端口输入/输出寄存器                       | 是                           |
| P0.0 ~ P3.7        | 各端口位                                  | 是  |
|**PCON**				|最高位为波特率倍增位							|否|

## 寄存器B:

乘法指令:B存放乘积的高八位,A存放乘积的低八位;

除法指令:A/B = A.....B

# 最小应用系统

本身的256B的RAM加上8KB的flash,4个I/O口;在外接时钟电路和复位电路;就可以构成最小应用系统;

## 时钟电路设计

1.S52的最大频率为33MHz

2.一般采用12或6

3.串行通信 一般采用11.0592MHz可以得到准确的波特率

4.如果需要多个单片机同步工作,需要外部振荡器信号

## 波特率:

波特率（Baud rate）在电子通信领域中是一个重要的概念，它指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。简而言之，波特率是对符号传输速率的一种度量，表示的是每秒钟内通信线路状态改变的次数。

# 8051指令系统与编程基础

## 8051指令系统的寻址方式

### 指令系统概述

简单,易掌握,效率较高的指令系统,复杂指令集

按所占字节分,分三种:

1)  单字节指令49条;

2)  双字节指令45条;

3)  三字节指令17条;

    按执行时间来分,分三种:

    (1)1个机器周期(12个时钟振荡周期)的指令64条;

    (2)2个机器周期指令45条

    (3)4个机器周期----乘除指令

## 指令格式:

指令的表示方法,通常由操作码和操作数组成

操作码---指令进行什么操作

操作数---指令的操作对象

## 指令系统的寻址方式

寻址方式:

在指令中说明操作数所在地址的办法

1.  寄存器寻址方式

    Eg: MOV A, Rn;

2.  直接寻址方式

    Eg: MOV A, 00H;

    直接寻址时访问片内所有特殊功能寄存器的唯一寻址方式

3.  寄存器间接寻址方式

    Eg: MOV A, @Ri;

    可以间接寻址的寄存器只有:R0,R1,DPTR,SP

4.  立即数寻址

    Eg: MOV A, \#40;

5.  基址寄存器

    Eg: MOVC A, @A+DPTR;

    Eg: MOVC A, @Rn+PC;

    Eg: JMP A, @Rn+DPTR;

6.  相对寻址

    Eg: 2000H:SJMP 08H

    Eg: SJMP LOOP

7.  位寻址

    Eg: MOV C, 40H;

## 汇编指令

共111条,按功能分为5类:

1)  数据传送类

2)  算数运算类

3)  逻辑操作类

4)  控制转移类

5)  位操作类

### 简单介绍指令用到的符号

Rn:当前寄存器区的8个工作寄存器R0-R7

Ri:当前寄存器区中作为间接寻址寄存器的俩个寄存器R0,R1

direct:

\#data:

\#data16:

DPTR:

rel:

C或CY:

addr11:

addr16

@:

(x):表示x地址单元或寄存器中的内容

((x)):表示以x单元或寄存器中的内容作为地址间接寻址单元的内容

-\>:箭头右边的内容被箭头左边的内容所取代

### 数据传送类指令

MOV \<目的操作数\>,\<源操作数\>;

### 堆栈操作指令

1)  进栈指令

PUSH:压栈,先将SP+1,在压栈

2)  出栈指令

POP:出栈,先将内容出栈,再将SP-1;

### 累加器A与外部数据存储器RAM/IO传送指令

MOVX \<目的操作数\>,\<源操作数\>;其中之一为A

### 查表指令

MOVC A,@A+PC

MOVC A,@A+DPTR

### 字节交换指令

XCH A, Rn;\`

XCH A, direct;

XCH A, @Ri;

### 半字节交换指令

XCHD A,@Ri;累加器的低4位与内部RAM低4位交换

### 算数运算类指令

会影响PSW的(Cy)(Ac)(OV)

但是增一和减一指令不影响这些标志.

1.  加法指令:ADD A, Rn;

    eg:

    0100 0011 + 1111 1100 = 1 0100 1111;

&nbsp;

1)  = 4FH,Cy=1,Ac=0,OV=0,P=1;

&nbsp;

2.  带进位加法指令:ADDC A, Rn;

3.  增1指令:INC A

    不影响PSW的任何标志

4.  十进制调整指令:DA A ;把A调整

5.  带借位的减法指令:SUBB A, Rn;

6.  减一指令:DEC A;  
    若原来为00H,减一变为FFH,不影响标志位(P标志位除外).

7.  乘法指令:MUL AB;

    低八位在A,高八位在B;如果积大于255,则OV置1,否则OV清0.Cy标志总是清0;

8.  除法指令:DIV AB; 商-\>A,余数-\>B;

    商存放在A,余数存放在B,且Cy和溢出标志位OV清0.如果B的内容为0,则存放结果的A,B中的内容不定,并溢出标志位OV置一.

### 逻辑操作类指令

1.  累加器A清0指令:CLR A; clear

2.  累加器A求反指令:CPL A; complement

3.  左环移指令:RL A;

4.  带进位左环移指令:RLC A;

5.  右环移指令:RR A;

6.  带进位的右环移指令;RRC A;

7.  累加器半字节交换指令:SWAP A;

8.  逻辑与指令:ANL A, Rn;

9.  逻辑或指令:ORL A, Rn;

10. 逻辑异或指令:XRL A,Rn;

### 控制转移类指令

1.  长转移指令:LJMP addr16;

2.  相对转移指令:SJMP rel;rel为带符号的二进制补码数,所以可以往上跳转;

3.  绝对转移指令:AJMP addr11;

4.  间接跳转指令:JMP @A+DPTR;

5.  条件转移指令:

    JZ rel; 如果累加器内容为0,则执行转移

    JNZ rel; 如果累加器内容非0.则执行转移

6.  比较不相等转移指令:CJNE A,direct,rel;

7.  减一不为0转移指令:DJNZ Rn,rel;

8.  调用子程序指令

&nbsp;

1)  长调用指令:LCALL addr16;

2)  绝对调用指令:ACALL addr11;

&nbsp;

9.  子程序返回指令:RET ;

10. 中断返回指令:RETI;

11. 空操作指令 NOP

### 位操作指令

1.  数据位传送指令:MOV C,bit;

2.  位变量修改指令:

&nbsp;

1)  CLR C; Cy位清0

2)  CLR bit; bit位清0

3)  CPL C; Cy位求反

4)  CPL bit; bit位求反

5)  SETB C; Cy位置一

6)  SETB bit; bit位置一

7)  CLR C; Cy位清0

8)  CLR 27H;

9)  CPL 08H;

10) SETB P1.7;

&nbsp;

3.  位变量逻辑与指令

    ANL C,bit;

    ANL C,bit;

4.  位变量逻辑或指令

    ORL C,bit

5.  条件转移类指令

    JC rel;

    JNC rel;

    JB bit,rel;

    JNB bit,rel;

    JBC bit,rel;

# 8051汇编语言程序设计基础

## 汇编语言语句和格式:

指令语句

伪指令语句

# 汇编程序基础

## 编写程序要求

1)  分析问题,确定算法或解题思路

2)  画流程图

3)  编写源程序

4)  汇编和调试

# AT89S52单片机的中断系统

## 为什么要用外部中断

外部中断可以迅速查询到外部的变化,直接响应外部程序,比如震动传感器,跳变很快,不方便软件查询,此时可以使用中断响应.

# AT89S52单片机的定时器/计数器

QUESTION:

> 当t0工作在方式3时,T1时怎么作为串行口的波特率发生器的

# T2定时计数器没有看如果有需要的话可以返回看,天津科技大学单片机原理.....讲的很详细

# 串口

## SBUF接收时的流程

接收中断：通常，当数据被接收到 SBUF 时，会触发一个接收中断。程序会在中断服务程序中执行 mov A, SBUF 来读取数据。这意味着在中断服务程序被调用并执行 mov A, SBUF 之前，SBUF 就已经包含了接收到的数据。

## 串口通信为什么需要延时

因为要等待串口将完整的数据帧发送出去,数据时一个一个往外发,一个机器周期会导致数据没有发全.

## 串行口的4种工作方式:

### 工作方式0:

作用:主要用于串行口外接移位寄存器,扩展并行I/O口.

数据帧:8位数据为一帧,无起始位与停止位.

波特率:固定为时钟的12分频.

### 工作方式1:

数据帧:10位一帧,包含起始位和停止位 

波特率:选用定时器1作为波特率 发生器,波特率与定时器一的溢出率有关

作用:双机串行通讯

接受数据问题:执行cmd = SBUF之后,等外面把RI置1,如果中断没开的话,while()

### 工作方式2:

作用:第9位为异步通信接口

波特率:波特率固定

数据帧:11wei

### 工作方式3:

除了波特率可变和工作方式2没有区别

## 蓝牙模块

### 使用方法:

1. 接入电源,接入发送与接收口
2. 使用微信小程序打开蓝牙通信助手
3. 在单片机写入需要发出与接受的程序
4. 通过小程序接受单片机发出的程序以及可以往单片机里面写入程序.

## WIFI模块

### 初始化(入网设置):

​		ESP-01s出厂波特率正常是115200, 注意：AT指令，控制类都要加回车，数据传输时不加回车

​		上电后发送AT指令测试通信及模块功能是否正常

​		通过一下命令配置成9600波特率

```c
AT+UART=9600,8,1,0,0
```
```c
# include <reg52.h>
/*
让51单片机发送指令,初始化wifi,让wifi模块的发送端接电脑
就可以接收到WiFi模块是否接受成功
学了LCD1602还可以使用LCD来观测是否接受成功
*/
code char in_net[] = "AT+CWJAP=\"YXS1005\",\"yuanxueshe1005\"\r\n";//入网
code char connect_server[] = "AT+CIPSTART=\"TCP\",\"192.168.1.247\",8880\r\n";//连接服务器
code char open_TC[] = "AT+CIPMODE=1\r\n";//打开透传
code char send_message[] = "AT+CIPSEND\r\n";//发送信息
char name[] = "furongyuhandsome";

void init_t1 (void);//1.初始化定时器1
void init_ts (void);//2.初始化串口通讯
void delay1s(int);
void sendstring (char* zifu);//将字符串发送出去
void main (void)
{
    P2 = 0xff;
    init_t1();
    init_ts();
    P2 = 0XFF;
    while(1)
    {
        delay1s(5);
        sendstring(in_net);
        delay1s(5);
        delay1s(5);
        sendstring(connect_server);
        delay1s(5);
        delay1s(5);
        sendstring(open_TC);
        delay1s(5);
        sendstring(send_message);
        delay1s(5);
        sendstring(name);
        delay1s(5);
    }
    return;
}
//1.初始化定时器1
void init_t1 (void)
{
    TMOD = 0X20;//定时器1,选择方式2
    TH1 = 0xfd;
    TL1 = 0xfd;
    TR1 = 1;//打开定时器
    return;
}
//2.初始化串口通讯
void init_ts (void)
{
    SCON = 0x50;//选用串口方式1,ren打开
    PCON &= 0x7f;//波特率位9600
    return;
}
void delay1s(int m)	//@11.0592MHz
{
    unsigned char data i, j, k;
    while(m--)
    {
        i = 8;
        j = 1;
        k = 243;
        do
        {
            do
            {
                while (--k);
            } while (--j);
        } while (--i);
    }
}
//将字符串发送出去
void sendstring (char* zifu)
{
    int i = 0;
    while(zifu[i] != '\0')
    {
        SBUF = zifu[i];
        while(TI == 0);
        TI = 0;
        i++;
        P2 = --P2;
    }
    return;
}
```

[]()

个人理解:通过AT指令可以更改wifi模块的设置,比如改为路由模式或者设备模式等等.将wifi模块通过CH340模块连接到电脑,通过电脑发送指令对wifi模块进行设置,所以可以让其连接在单片机上.通过串口让单片机发送指令,改变WiFi模块的设置

# 串行口举例往后都没看

# C51

## C51的数据类型与存储类型

### 数据类型:

扩展了4中数据类型:

1.  bit:位变量

2.  sfr:8位特殊功能寄存器

sfr占用一个内存单元,利用它可以访问51单片机内部所有特殊功能寄存器

3.  sfr16:16位特殊功能寄存器

4.  sbit:可进行位寻址的特殊功能寄存器的某位的绝对地址

    具体可以参考\<reg52.h\>内的内容

### 存储类型

data:片内ram直接寻址区,位于片内ram的低128字节

idata:片内ram的256字节,必须间接寻址的存储区

bdata:片内ram位寻址区,位于20h~2fh之间

xdata:片外64kb的ram,使用@DPTR间接寻址

pdata:片外ram的256个字节,使用@Ri间接寻址

code:程序存储区,使用DPTR寻址

## 绝对宏

CBYTE:以字节形式对code区寻址

CWORD:以字形式对code区寻址

DBYTE:以字节形式对data区寻址

DWORD:以字形式对data区寻址

XBYTE:以字节形式对xdata区寻址

XWORD:以字形式对xdata区寻址

PBYTE:以字节形式对pdata区寻址

PWORD:以字形式对data区寻址

\_at_关键字,可以对指定的存储器空间的绝对地址访问,格式如下:

\[存储器类型\]数据类型说明符 变量名_at\_ 地址常数

# 特殊功能寄存器AUXR

1. 可以用来关闭ALE输出

# 模块化编程流程



# include 中<>和""的异同

在C和C++中，`#include`指令用于包含头文件，以便在源代码中使用定义在头文件中的宏、函数声明、类定义等。`< >`和`""`这两种括号用于指定包含文件的搜索路径，它们之间存在一些重要的区别：

1. 搜索路径
   - 使用尖括号`< >`时，预处理器会首先在标准库目录中查找头文件。这些目录通常是由编译器或开发环境指定的。
   - 使用双引号`""`时，预处理器首先在当前源文件所在的目录中查找头文件。如果找不到，它才会去标准库目录或编译器指定的其他目录中查找。
2. 项目组织和可移植性
   - 使用尖括号`< >`通常用于包含标准库头文件，如`<iostream>`、`<vector>`等。这样做的好处是代码更加标准化和可移植，因为不论你的源代码位于哪里，预处理器都会在相同的标准库目录中查找这些头文件。
   - 使用双引号`""`则常用于包含项目或应用特有的头文件，或者是那些你希望从当前源文件所在的目录开始查找的头文件。这有助于组织项目结构，并确保在特定的项目或应用上下文中正确地找到头文件。
3. 防止头文件重复包含
   - 无论是使用尖括号还是双引号，为了避免头文件的重复包含，通常会在头文件的开头和结尾使用预处理器指令`#ifndef`、`#define`和`#endif`来定义一个唯一的标识符，即所谓的头文件保护符或包含守卫。

示例：

```cpp
// 使用尖括号包含标准库头文件  
#include <iostream>  
  
// 使用双引号包含项目特有的头文件  
#include "myprojectheader.h"
```

在实践中，你应该根据头文件的来源和用途来选择使用尖括号还是双引号。标准库头文件总是使用尖括号，而项目特有的头文件则通常使用双引号。这样做有助于保持代码的清晰和组织结构的一致性。

# LCD1602

## 如何使用LCD1602

一.先要将LCD1602初始化

1. 检查忙,只有不忙的时候才能进行别的操作,所以此函数需要先写
2. 写命令,想要初始化LCD,就需要往里写命令,将LCD初始化
3. 初始化,通过写命令初始化LCD
4. 写数据
5. 写字符串

二.然后在选定的位置输出想要的字符

## 时序介绍--了解LCD1602的时序,才能准确的进行读写操作

LCD1602的读写操作主要涉及到几个关键的引脚，包括RS（寄存器选择）、R/W（读写信号线）和E（使能端），以及数据口D0~D7。

在写操作时，如果需要设置LCD1602的工作方式或发送指令字，需要将RS置为低电平，RW置为低电平，然后将数据送到数据口D0~D7，最后E引脚给一个高脉冲将数据写入。而如果需要写入数据字以在LCD1602上显示内容，则需要将RS置为高电平，RW置为低电平，同样将数据送到数据口D0~D7，并通过E引脚的高脉冲将数据写入。

在读操作时，主要涉及到RS和R/W引脚的配置。例如，当RS为低电平且R/W为高电平时，可以读取忙信号。

对于时序要求，这通常涉及到各个引脚电平变化的顺序和持续时间。例如，E引脚的高脉冲需要持续一定的时间才能有效写入数据。这些时序要求通常可以在LCD1602的数据手册或相关资料中找到。

# DHT温湿度传感器

1. 需要先发送触发信号
2. 温湿度传感器接收触发信号后会发送40个周期型号,先是50us的低电平,接着是23~28us的高电平(表示0),或者70um的高电平(表示1),一共40位,依次为
   - 湿度整数位
   - 湿度小数位
   - 温度整数位
   - 温度小数位
# IIC

为什么在SCL高电平时不允许进行数据变换:在数据传输期间,只要时钟线为高电平,数据线都必须稳定,否则数据线上的任何变化都当作起始或终止信号.

scl和sda平时是处于什么状态

已知sda在没有数据发送或接收为高电平

书上有些空闲时俩条线都是高电平

如果终止信号是scl在低电平的话,下一次启动,会把sda拉高,在scl为低电平的情况下,拉高sda没有影响,若是先拉高scl,在拉高sda,和scl一直处于高电平也没有区别.

## IIC总线通信过程:

1. 主机发送起始信号启用总线
2. 主机发送一个字节数据指明从机地址和后续字节的传送方向
3. 被寻址的从机发送应答信号回应主机
4. 发送器发送一个字节数据
5. 接收器发送应答信号回应发送器
6. ... ... (循环步骤4,5)
7. 通信完成后主机发送停止信号释放总线

## IIC的寻址方式

先发7位地址位,再发一位读写位;

## IIC总线信号实现

时序图

# oled

```c
//1.OLED初始化
Oled_Init();
//2.选择一个位置
//2.1确认页寻址模式
Oled_Write_Cmd(0x20);
Oled_Write_Cmd(0x02);
Oled_Clear();
//2.2选择PAGE0 10110000 
Oled_Write_Cmd(0xB0);//this is page 0
Oled_Write_Cmd(0x00);//this is writing from 0;
Oled_Write_Cmd(0x10);
```



## 同步信号

scl线设计

# 51报错

##  WARNING L13: 

RECURSIVE CALL TO SEGMENT 对段的递归的调用 

第一次解决:主函数调用子函数,子函数调用含参延时函数,把子函数的实参改为void就可以;

---



##  WARNING L16:

 UNCALLED SEGMENT, IGNORED FOR OVERLAY PROCESS :当编译器在分析代码时检测到某个函数或数据段（Segment）未被任何其他代码直接或间接调用（即未被引用），并且编译选项启用了数据覆盖功能时，它会发出这条警告。这意味着编译器认为这个未被调用的段在运行时不会被执行，因此在生成覆盖映射表（Overlay Map）时将其忽略，不会为其分配存储空间。

就是函数被定义了,但是没有调用,程序不为此函数分配内存,并警告你一下

# warning C316:

 unterminated conditionals 存在一个未正确结束的条件编译指令序列

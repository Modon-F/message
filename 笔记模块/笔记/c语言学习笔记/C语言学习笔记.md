# 第1章 初识C语言

# 1.1 C语言的起源

## 1.2 选择C语言的理由

1.2.1 设计特性
1.2.2 高效性
1.2.3 可移植性
1.2.4 强大而灵活
1.2.5 面向程序员
1.2.6 缺点
1.3 C语言的应用范围
1.4 计算机能做什么
1.5 高级计算机语言和编译器
1.6 语言标准
1.6.1 第1个ANSI/ISO C标准
1.6.2 C99标准
1.6.3 C11标准
1.7 使用C语言的7个步骤
1.7.1 第1步：定义程序的目标
1.7.2 第2步：设计程序
1.7.3 第3步：编写代码
1.7.4 第4步：编译
1.7.5 第5步：运行程序
1.7.6 第6步：测试和调试程序
1.7.7 第7步：维护和修改代码
1.7.8 说明
1.8 编程机制
1.8.1 目标代码文件、可执行文件和库
1.8.2 UNIX系统
1.8.3 GNU编译器集合和LLVM项目

1.8.4 Linux系统
1.8.5 PC的命令行编译器
1.8.6 集成开发环境（Windows）
1.8.7 Windows/Linux
1.8.8 Macintosh中的C
1.9 本书的组织结构
1.10 本书的约定
1.10.1 字体
1.10.2 程序输出
1.10.3 特殊元素
1.11 本章小结
1.12 复习题
1.13 编程练习

# 第2章 C语言概述

2.1 简单的C程序示例
2.2 示例解释
2.2.1 第1遍：快速概要
2.2.2 第2遍：程序细节

2.3 简单程序的结构
2.4 提高程序可读性的技巧
2.5 进一步使用C
2.5.1 程序说明
2.5.2 多条声明
2.5.3 乘法
2.5.4 打印多个值
2.6 多个函数
2.7 调试程序
2.7.1 语法错误
2.7.2 语义错误
2.7.3 程序状态
2.8 关键字和保留标识符
2.9 关键概念
2.10 本章小结

## 2.11 复习题

1. 函数

2. 就是c语言的基本规则使用错误
	英语上的语法错误: you is a boy;
	语义错误:

	```c
	#include <stdio.h>
	
	//实现输出"我是帅哥"
	int main (void)
	{	
	    pritnf("我不是帅哥")
		return 0;
	}
	```

	

2.12 编程练习

# 第3章 数据和C

3.1 示例程序
3.2 变量与常量数据
3.3 数据：数据类型关键字
3.3.1 整数和浮点数
3.3.2 整数
3.3.3 浮点数
3.4 C语言基本数据类型
3.4.1 int类型
3.4.2 其他整数类型
3.4.3 使用字符：char类型
3.4.4 _Bool类型
3.4.5 可移植类型：stdint.h和inttypes.h
3.4.6 float、double和long double
3.4.7 复数和虚数类型
3.4.8 其他类型
3.4.9 类型大小
3.5 使用数据类型
3.6 参数和陷阱

3.7 转义序列示例
3.7.1 程序运行情况
3.7.2 刷新输出
3.8 关键概念
3.9 本章小结
3.10 复习题
3.11 编程练习
第4章 字符串和格式化输入/输出
4.1 前导程序
4.2 字符串简介
4.2.1 char类型数组和null字符
4.2.2 使用字符串
4.2.3 strlen()函数
4.3 常量和C预处理器
4.3.1 const限定符
4.3.2 明示常量
4.4 printf()和scanf()
4.4.1 printf()函数

4.4.2 使用printf()
4.4.3 printf()的转换说明修饰符
4.4.4 转换说明的意义
4.4.5 使用scanf()
4.4.6 printf()和scanf()的*修饰符
4.4.7 printf()的用法提示
4.5 关键概念
4.6 本章小结
4.7 复习题
4.8 编程练习
第5章 运算符、表达式和语句
5.1 循环简介
5.2 基本运算符
5.2.1 赋值运算符：=
5.2.2 加法运算符：+
5.2.3 减法运算符：-
5.2.4 符号运算符：-和+
5.2.5 乘法运算符：*

5.2.6 除法运算符：/
5.2.7 运算符优先级
5.2.8 优先级和求值顺序
5.3 其他运算符
5.3.1 sizeof运算符和size_t类型
5.3.2 求模运算符：%
5.3.3 递增运算符：++
5.3.4 递减运算符：--
5.3.5 优先级
5.3.6 不要自作聪明
5.4 表达式和语句
5.4.1 表达式
5.4.2 语句
5.4.3 复合语句（块）
5.5 类型转换
5.6 带参数的函数
5.7 示例程序
5.8 关键概念

# Library

https://zlibrary-sg.se/?remix_userid=36643710&remix_userkey=010f100c2dc8264c1b8cef4e73d638ba

# If else if 的用法

数组名的本质上是指向数组中第一个元素的指针常量，也可以说是一个指向自己地址的指针常量。它的类型取决于数组元素的类型，如果它们是int类型，那么数组名的类型就是"指向init的指针常量"。请不要根据这个事实得出数组名和指针是相同的结论，数组名在某些场合具有和指针完全不同的特征。也就是说，数组名是一个特殊指针，不能完全等同指针。很魔幻是不是，咱们来说一说数组名和指针到底有什么区别。

# Scanf的用法 

功能:

将键盘输入的字符转化为输入控制符所规定格式的数据,然后存入以输入参数的值为地址的变量中.

注意:

Scanf输入时哪里有错误,就停在哪里,下次输入还会从错误的地方往下扫描.

while (ch = getchar() != '\n')

continue;

用来清空前面所有的字符,直到扫描到回车

# Malloc

(Sizeof)malloc(xxx)返回值为8个字节

(Sizeof)malloc(数组名)返回值为数组总共占用的字节.

# ++和--

While(i--)是先判断while(i) ,然后在对i进行--操作.

While(--i)是先对i进行--,然后在判断while(i);

# While

While(表达式),表达式的内容非0即1;比如表达式 = -1;等价于while(1);

# 数据运算的顺序

## 优先级别:

算术\>关系\>逻辑\>赋值

# 枚举

## 什么是枚举

把一个事物所有可能的取值一一列举出来

## 怎样使用枚举

```c
# include \<stdio.h\>

//只定义了一个数据类型,并没有定义变量,该数据类型的名字叫做 enum WeekDay

enum WeekDay

{

    Monday, Tuesday, Wednesday

};

int main(void)

{

    enum WeekDay day;

    day = Monday; //不能赋值为0,只能赋值枚举内规定的值;0只是它的物理实现方式.

    printf("%d",day);

    return 0;

}
```



## 枚举的优缺点

代码更安全

书写麻烦

# Exit

作用:直接退出程序

需要头文件 \# include \<stdlib.c\>

# 变量四要素

1. 数据类型 ： 决定在内存中分配的空间  
   2.变量名 ： 空间别名  
   3.值 ：空间中存储的数据

   4.地址

# 数组

## 二维数组

a\[3\]\[4\]; 此时若是再取a\[0\]代表的是地址.

a+1代表的是第二行的首地址

a\[0\]+1,代表的是第一行第二个元素的地址

a\[0\]和a+0不是一个东西

思想:把每个维度看作上一个维度的一维数组

![屏幕截图 2024-03-10 223456](media/image1.png)

## 关于指针的一些小公司的考题

![屏幕截图 2024-03-10 233446](media/image2.png)

## 数组指针

### 定义:

定义一个指针,指向一个数组

### 模板:

Int (\*P)\[4\];定义了一个变量指向16个字节的整形指针变量

P = arr; 可以将数组名发送给p,此时不会报错

## 指针数组

### 定义:

一个数组,若其元素均为指针类型数据,称为指针数组,也就是说,指针数组中的每一个元素都存放一个地址,相当于一个指针变量;

### 指针数组如何保存函数指针

如何定义一个函数指针数组:

在定义的函数指针变量后面加\[size\]就可以实现

# 指针函数

## 特点:

返回指针值的函数

# 函数指针

## 定义函数地址

如果在程序中定义了一个函数,在编译时,编译系统为函数代码分配一段存储空间,这段存储空间的起始地址(又称入口地址)称为这个函数的指针;

补充:函数名就是地址

## 如何定义一个函数指针变量

int getData(int a,int b);

int (\*p)(int a,int b);

p = getData;

# 输入输出函数

## puts和printf和使用异同

1.puts()函数只用来输出字符串，里面的参数可以直接是字符串或者是存放字符串的字符数组名，不能输出数值或进行格式变换。

2.printf（）函数的输出格式很多，可以根据不同格式加转义字符，达到格式化输出。

3.puts（）函数的作用与语句printf("%s\n",s)的作用形同。

4.puts()在输出字符串后，会自动换行，而printf不会自动换行。

5.printf显示更清晰，puts运行更快。

# 字符串

## 字符和字符串:

## 自我验证与补充:

“furongyu”;这样会返回该字符串的首地址,通过首地址可以找到该字符串,也可以直接找到第一个字符.

## 结束标志:

字符串的结束标志\0

## sizeof和strlen的区别:

strlen:这是函数

函数原型:unsigned int strlen (char \* str);

功能:统计字符串str中字符的个数(不包括串结束符’\0’)

sizeof:这是关键字

计算数据类型所占内存单元字节数

## malloc

malloc分配的内存空间在堆区

## strcpy

函数原型:char\* strcpy(char\* str1,char\* str2);

功能:把字符串str2复制到字符串str1中去,即用字符串str2覆盖字符串str1;

返回值:str1

注意事项:使用时要添加头文件\<string.h\>

## realloc 这个可能有问题

函数原型: void \*realloc(void \*ptr, int size);

功能:C 库函数 void \*realloc(void \*ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。

## assert

自我总结:assert(需要判断的语句);如果语句为0,结束程序,并告诉你语句是错的;

以下为chatgpt提供:

assert是宏而不是函数，它主要用来在调试时判断一个语句是否为真。assert的用法如下：

1.在使用assert时，先计算表达式。如果表达式的值为假（即为0），那么assert会先向stderr打印一条出错信息，然后通过调用abort来终止程序运行。

2.assert在函数的开始处可以用来检验参数的合法性。

3.每个assert只应检验一个条件，因为如果同时检验多个条件，当断言失败时，无法直观判断是哪个条件失败。

4.由于assert只在DEBUG环境生效，因此不能使用改变环境的语句。例如，不能写assert(i++ \< 100)，因为如果出错，比如在执行之前i=100，那么这条语句就不会执行，导致i++这条命令没有执行。正确的写法应该是assert(i \< 100); i++;。

## strcat

### 函数原型:

char\* strcat (char\* str1, char\* str2);

### 功能:

将str2所指向的字符串连接到字符串str1的后面,取消原来str1最后面的串结束符;

### 返回值:

返回str1;

## strcmp

### 函数原型:

int strcmp (char\* str1, char\* str2);

### 功能:

比较字符串str1和str2相应字符的大小,遇到第一个不相等的字符为止;

### 返回值:

str1\<str2;返回负数

str1=str2;返回0

str1\>str2;返回正数

# 字符串函数

## strstr

* `strstr` 函数是 C 语言标准库中的一个函数，用于在字符串中查找子串。它的原型定义在 `<string.h>` 头文件中。`strstr` 函数用于在给定的字符串中查找第一次出现的子串，并返回指向子串的指针。如果未找到子串，则返回 `NULL`。
  函数原型如下：
  
  ```c
  char *strstr(const char *haystack, const char *needle);
  ```
  参数说明：
  - `haystack`：指向要搜索的字符串的指针，通常被称为“堆”。
  - `needle`：指向要查找的子串的指针，通常被称为“针”。
  返回值：
  - 如果 `needle` 是 `haystack` 的子串，则返回指向 `haystack` 中 `needle` 第一次出现的指针。
  - 如果 `needle` 不是 `haystack` 的子串，或者 `haystack` 或 `needle` 为空，则返回 `NULL`。
  示例：
  ```c
  #include <stdio.h>
  #include <string.h>
  int main() {
      const char *haystack = "Hello, world!";
      const char *needle = "world";
      char *result = strstr(haystack, needle);
      if (result) {
          printf("The substring '%s' was found in '%s'.\n", needle, haystack);
      } else {
          printf("The substring '%s' was not found in '%s'.\n", needle, haystack);
      }
      return 0;
  }
  ```
  在这个例子中，`strstr` 函数将在 `haystack` 字符串中查找 `needle` 子串。由于 "world" 是 "Hello, world!" 的子串，`strstr` 将返回指向 "world" 的指针，程序将输出 "The substring 'world' was found in 'Hello, world!'."。
  需要注意的是，`strstr` 函数对大小写敏感。如果需要进行大小写不敏感的搜索，可以使用 `strcasestr`（在某些系统上可用）或者自己实现一个大小写不敏感的搜索函数。

# 关键字

## **static**

### **局部静态变量:**

与普通的局部变量不同,局部静态变量在函数调用结束后,不会被销毁,而是保留其值存在.

```c
# include <stdio.h>

int sta(void);
int main(void)
{
​	int i;
​	sta();
​	sta();
​	i = sta();
​	printf("%d",i);
​	return 0;
}
int sta(void)
{
​	static int count = 0;
​	for (int i = 0; i < 5; i++)
​		count++;
​	return count;
}
```

### **全局静态变量:**

使用static修饰的全局变量,只可以使其在声明所在的文件内可见,这样可以避免与其他文件中,相同名称的变量名产生冲突.

### **静态函数:**

需要static修饰的函数称为静态函数,这种函数只能在函数声明所在的文件内部调用.无法被其他文件直接调用.

## const

在C语言中，`const`关键字用于声明一个变量为只读，这意味着一旦这个变量被初始化后，它的值就不能被修改。`const`提供了程序的可靠性和可维护性，因为它可以确保某些变量不会被意外地修改。

以下是`const`在C语言中的一些常见用法：

### 1. 定义常量

使用`const`可以定义常量，这些常量的值在程序运行期间不能改变。

```c
const int MAX_VALUE = 100; // MAX_VALUE是一个常量，其值不能改变
```

### 2. 指向常量的指针

当指针指向一个`const`变量时，你不能通过这个指针修改所指向的值。

```c
const int a = 5;  
const int *p = &a; // p指向一个常量，因此不能通过p修改a的值  
// *p = 10; // 这行代码是错误的，因为不能通过p修改a的值
```

### 3. 常量指针

可以声明一个指针本身为`const`，这意味着这个指针的值（即它所指向的地址）不能被修改，但是它所指向的内容可以被修改（除非内容本身也是`const`）。

```c
int b = 20;  
int *const q = &b; // q是一个常量指针，它的值不能被改变  
// q = &a; // 这行代码是错误的，因为不能改变q的值  
*q = 30; // 这是允许的，因为q指向的内容（即b的值）可以被修改
```

### 4. 指向常量的常量指针

也可以同时声明一个指针既指向常量又本身是常量。

```c
const int c = 30;  
const int *const r = &c; // r是一个指向常量的常量指针  
// *r = 40; // 错误，不能通过r修改c的值  
// r = &b; // 错误，不能改变r的值（它指向的地址）
```

### 5. 在函数参数中使用`const`

在函数参数中使用`const`可以确保函数不会修改传递进来的参数。

```c
void printValue(const int x) {  
    // 在这个函数内部，你不能修改x的值  
    printf("%d\n", x);  
}
```

### 6. 在数组和结构体中使用`const`

`const`也可以用于数组和结构体，以确保其内容不会被修改。

```c
const int array[] = {1, 2, 3, 4, 5}; // 数组的内容是常量，不能被修改  
  
typedef struct {  
    const char *name;  
    int age;  
} Person;  
  
const Person person = {"Alice", 30}; // person的name字段是常量，不能被修改
```

使用`const`关键字可以帮助程序员清晰地表达哪些变量或数据是不应该被修改的，从而提高代码的可读性和可维护性。同时，编译器也会帮助检查`const`的使用，确保没有违反这些限制。

# 补充:

## !和~的异同

在C语言中，`!` 和 `~` 是两种不同的运算符，它们有各自的功能和用法。

1. `!`（逻辑非运算符）：
   `!` 是一个逻辑非运算符，用于对布尔值进行取反操作。如果操作数的值为真（非零），则 `!` 运算符返回假（0）。如果操作数的值为假（0），则 `!` 运算符返回真（非零）。

​	2.`~`（按位取反运算符）：
​	`~` 是一个按位取反运算符，用于对一个整数的二进制表示进行取反操作。它将操作数的每一位都取反，即0变为1，1变为0

## 加减乘除的精度与符号问题详解

在 C 语言中，加减乘除的精度和符号问题主要与所使用的数据类型有关。C 语言提供了几种基本的数据类型来表示数字，包括整数类型（如 `int`、`short`、`long` 等）和浮点类型（如 `float`、`double`）。每种数据类型都有其固定的表示范围和精度。
1. 整数类型：
   - 加法、减法和乘法：整数运算通常不会有精度损失，因为整数运算是在整数范围内精确进行的。但是，如果结果超出了数据类型的表示范围，会发生溢出，这可能导致未定义的行为。
   - 除法：整数除法会丢弃小数部分，只保留整数部分。如果需要小数结果，必须使用浮点数进行除法。
2. 浮点类型：
   - 加法、减法和乘法：浮点数运算可能会有精度损失，因为浮点数通常使用有限的位数来表示，这可能导致舍入误差。`float` 类型通常提供大约 6-7 位的十进制精度，而 `double` 类型提供大约 15-16 位的十进制精度。
   - 除法：浮点数除法不会像整数除法那样丢弃小数部分，它会保留结果的小数部分。但是，如果除数为 0，结果将是无穷大或 NaN（不是数字）。
   符号问题：
- 加法和减法：符号问题主要出现在结果的符号上。如果操作数异号，结果将是负数。如果操作数同号，结果将是正数。在整数运算中，如果结果超出了数据类型的表示范围，符号位可能会翻转，导致意外的结果。
- 乘法：乘法结果的符号由两个操作数的符号决定。如果两个操作数同号，结果为正；如果异号，结果为负。
- 除法：除法结果的符号也由两个操作数的符号决定。如果两个操作数同号，结果为正；如果异号，结果为负。在整数除法中，如果除数为 0，会导致运行时错误。
示例：
```c
#include <stdio.h>
int main() {
    int a = 10;
    int b = 3;
    float c = 10.0f;
    float d = 3.0f;
    printf("整数加法： %d\n", a + b); // 13
    printf("整数减法： %d\n", a - b); // 7
    printf("整数乘法： %d\n", a * b); // 30
    printf("整数除法： %d\n", a / b); // 3，丢弃了小数部分
    printf("浮点数加法： %f\n", c + d); // 13.000000
    printf("浮点数减法： %f\n", c - d); // 7.000000
    printf("浮点数乘法： %f\n", c * d); // 30.000000
    printf("浮点数除法： %f\n", c / d); // 3.333333，保留了小数部分
    return 0;
}
```
在处理精度敏感的应用时，应该使用 `double` 类型而不是 `float` 类型，因为 `double` 提供了更高的精度。如果需要极高的精度，可能需要使用特定的数学库或自定义的数据类型。

# 郝斌boss王飞语录

计算机把你360°扫描一遍,但是如果你有一次冲它笑了一次,计算机又傻眼了,又不认识了,但人则不一样,如果你当初深深的望了某人一眼,肯定能若干年后也忘不掉!

# 数据结构定义

我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中,以及在此基础上为实现某个功能而执行的相应操作,这个相应的操作也叫算法;

数据结构 = 个体 + 个体的关系

算法 = 对存储数据的操作

狭义算法:存储方式不一样,算法不一样

## 算法

### 解题的方法和步骤

### 衡量算法的标准

1. 时间复杂度

​		大概程序要执行的次数,而非执行的时间

2.  空间复杂度

    算法执行过程中大概所占用的最大内存

3.  难易程度

4.  健壮性

## 数据结构的地位

数据结构是软件中最核心的课程

程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言

## 预备知识

### 指针

指针的重要性:

指针是c语言的灵魂

定义:

地址:

1.  内存单元的编号

2.  从0开始的非负整数

3.  范围:0-FFFFFFFF{0-(4gG-1)}

    指针:

    指针就是地址 地址就是指针

    指针变量是存放内存单元地址的变量

    指针的本质是一个操作受限的非负整数

    分类:&nbsp;

1.  基本类型指针

2.  指针和数组的关系

    补充

    地址可以指向有效元素的下一个元素,但是不能使用这个位置.

### 结构体

为什么会出现结构体

为了表示一些复杂的数据,而普通的基本类型变量无法满足要求

什么叫结构体

结构体是用户根据实际需要自己定义的符合数据类型

如何使用结构体

俩种方式:

Struct Student st ={100,”zhang”,20}

Struct Student \*pst = &st;

1.  st.sid

2.  Pst-\>sid

    pst所指向结构体变量中的sid这个成员;

注意事项:

结构体变量不能加减乘除,但可以相互赋值;

普通结构体变量和结构体指针变量作为函数传参的问题;

在vs中使用strcpy会报错,在前面加上#pragma warning(disable:4996), 就可以解决这个问题

### 动态内存的分配和释放

# 模块一:线性结构

把所有的结点用一根直线穿起来

### 连续存储\[数组\]

1.  什么叫数组

    元素类型相同,大小相等

2.  数组的优缺点

### 离散存储\[链表\]

定义:

1.n个结点离散分配

2.彼此通过指针相连

3.每个结点只有一个前驱结点,每个结点只有一个后续结点

4.首结点没有前驱结点,尾结点没有后续结点

分类:

### 专业术语:

1.  首结点:第一个有效的结点

2.  尾结点:最后一个有效的结点

3.  头结点:

    第一个有效结点之前的那个结点

    头结点并不存放有效数据

    加头结点的目的主要是为了方便对链表的操作

    头结点的数据类型和首结点类型一样

4.  头指针:指向头结点的指针变量

5.  尾指针:指向尾结点的指针变量

### 确定一个链表需要几个参数:

Only one :头指针

### 链表的分类

单链表

双链表:

每一个结点有俩个指针域

循环链表:

能通过任何一个结点找到其他所有的结点

非循环链表

# 算法

## 如何学习算法

很多牛人对很多算法也是无从下手的,所以不需要妄自菲薄,如果想要把算法弄清楚,是需要数学功底的,所以空闲可以看看数学;

虽然自己想不明白算法,但是要把别人的算法看懂.

## 如何看懂别人的程序---三要素

1.流程

2.每个语句的功能

3.试数

狭义的算法是与数据的存储方式密切相关

广义的算法是与数据的存储方式无关

泛型:

利用某种技术达到的效果就是:不同的存储方式,执行的操作是一样的

遍历

查找

清空

销毁

求长度

排序

删除结点:

删除结点时要注意释放所删除结点所占用的内存;

插入结点

优缺点:

# 线性结构的俩种常见应用之一 栈

分类

静态栈

动态栈

算法

出栈

压栈

应用

函数调用

中断

表达式求值

内存分配

缓冲处理

迷宫

# 线性结构的俩种常见应用之二 队列

## 定义:

一种可以实现”先进先出”的存储结构.

## 分类:

链式队列--用链表实现

静态队列--用数组实现

静态队列通常都必须是循环队列

## 循环队列的讲解:

1.  静态队列为什么必须是循环队列

    减少内存的浪费

2.  循环队列需要几个参数来确定

    Front

    Rear

3.  循环队列的各个参数的含义

    俩个参数在不同的场合有不同的含义

    建议初学者先记住,然后慢慢体会

&nbsp;

1)  队列初始化

    front和rear的值都是零

2)  队列非空

    Front代表的是队列的第一个元素

    Rear代表的是队列的最后一个有效元素的下 一个;

3)  队列空

    Front和rear的值相等,但不一定是零

&nbsp;

4.  循环队列入队伪算法讲解

    两步完成:

&nbsp;

1)  将值存入r所代表的位置

2)  错误的写法: r = r + 1;

    正确的写法: rear = (rear+1)%(数组的长度);

&nbsp;

5.  循环队列出队伪算法讲解

    Front = (front+1)%(数组的长度);

6.  如何判断循环队列是否为空

    Front和rear是否相等;相等则为空

7.  如何判断循环队列是否已满

    预备知识:

    Front的值可能比rear大,也会比rear小,也可能相等,可以认为他俩互不影响;

    两种方式:

&nbsp;

1.  多增加一个表示参数

2.  少用一个元素(通常使用此方式)

    如果r和f的值紧挨着,则队列已满

    用c语言伪算法表示为:

if ((r + 1) % 数组的长度 == f)

已满;

else

不满;

## 队列的算法

入队

出队

## 队列的具体应用

所有和时间有关的操作都有队列的影子

## 递归

### 定义:

一个函数自己直接或间接调用自己

### 举例:

1.  1+2+3+4+....+100的和;

2.  求阶乘

3.  汉诺塔

4.  走迷宫

    以上程序见vs_3_7

### 递归的应用

树和森林就是以递归的方式定义的

树和图的很多算法都是以递归来实现的

很多的数学公式就是以递归的方式定义的

斐波拉契序列: 1,2,3,5.....

### 递归要满足的三个条件:

1.  递归必须要有一个明确的中止条件

2.  该函数所处理的数据规模必须在递减

3.  这个转化必须是可解的

### 循环和递归的关系:

所有的循环都可以用递归实现,但是递归不一定可以由循环实现

递归:

1.  易于理解

2.  速度慢

3.  存储空间大

    循环:

&nbsp;

1.  不易理解

2.  速度快

3.  存储空间小

# 函数的调用

当在一个函数的运行期间调用另一个函数时,在运行被调函数之前,系统需要完成三件事:

1.  将所有的实际参数,返回值等信息传给被调函数保存

2.  为被调函数的局部变量(也包括形参)分配存储空间

3.  将控制转移到被调函数的入口

    从被调函数返回主调函数之前,系统也要完成三件事:

&nbsp;

1.  保存被调函数的返回结果

2.  释放被调函数所占的存储空间

3.  依照被调函数保存的返回地址将控制转移到调用函数.

当有多个函数相互调用时,按照”后调用先返回”的原则,上述函数之间信息传递和控制转移必须借助”栈”来实现,即系统将整个程序运行时所需的数据空间安排在一个栈中,每当调用一个函数时,就在栈顶分配一个存储区,进行压栈操作,每当一个函退出时,就释放它的存储区,进行出栈操作,当前运行的函数永远都在栈顶位置.

模块二:非线性结构

树

图

模块三:查找和排序

折半查找

排序:

冒泡

插入

选择

快速排序

归并排序

Java中容器和数据结构相关知识

# 结构体

## 共用体/联合体

### 异同

1. 不同类型变量共享一块空间,相对于结构体节省空间;

- 同一时刻只能存在一个成员

2. 结构具体元素又各自单独空间,空间大小有最大类型确定;
3. 结构体元素互不影响,共用体赋值会导致覆盖;
4. 举例
 ```c
   # include <stdio.h>
   # include <string.h>
  
   union addr
   {
   	char addrStr[16];
   };
   
   int main(void)
   {
   	union addr ip;
   	strcpy_s(ip.addrStr,"192.168.0.1");
   	strcpy_s(ip.addrStr, "999.999.999.999");
   	printf("%s",ip.addrStr);
   	return 0;
   }
 ```

```
    999.999.999.999
C:\Users\15257\Desktop\vs\VS_TEST\x64\Debug\VS_TEST.exe (进程 12824)已退出，代码为 0。
按任意键关闭此窗口. . .
```



```
# 补充

## Typedef

```c
typedef struct student \*sT ,ST; //ST 等价于struct student sT等价于struct student\*
typedef struct student\* St; //St 等价于struct student\*
typedef struct student
    
{
int age;
int sid;
char name\[200\];
}\*sT, ST; //ST 等价于struct student sT等价于struct student\*
```

